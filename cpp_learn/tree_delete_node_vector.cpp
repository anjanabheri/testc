/*
Google Mock Interview Question:
You are given a binary tree, and a list of nodes to delete. After deleting all nodes in to_delete, 
we are left with a forest (a disjoint union of one or more trees). Return a list with a representation 
of each of these trees. Note: The representation of the tree is a list that follows a slightly 
modified heap pattern: [root, root-left, root-right, root-left-left, root-left-right, root-right-left, ...]. 
For any index i you can find its left child at 2i + 1 and right at 2i + 2. Any non-existent child would be 
represented by null to keep that property consistent. [1,2,3] becomes the tree 1 2 3 [1,null,3] becomes a
tree without a left child. 1 3 
Example 1: Input: tree = [1,2,3], to_delete = [1] Output: [ [2], [3] ] 
Example 2: Input: tree = [1,2,3,4], to_delete = [4] Output: [ [1, 2, 3] ] 
Example 3: Input: tree = [1,2,3,4,5,6,7], to_delete = [3,5] Output: [ [1, 2, 4, null], [6], [7]] 
Constraints: Each node in the tree has a distinct value. Each value in to_delete is distinct.
*/


//Generated by chatGPT

#include <iostream>
#include <vector>
#include <unordered_set>

using namespace std;

class Solution {
public:
    vector<vector<int>> delNodes(vector<int>& tree, vector<int>& to_delete) {
        unordered_set<int> to_delete_set(to_delete.begin(), to_delete.end());
        vector<vector<int>> result;
        unordered_set<int> roots;
        
        // Create a mapping from each node to its children
        vector<int> parent(tree.size(), -1);
        for (int i = 0; i < tree.size(); ++i) {
            if (tree[i] != -1) {
                if (i * 2 + 1 < tree.size()) parent[tree[i * 2 + 1]] = i;
                if (i * 2 + 2 < tree.size()) parent[tree[i * 2 + 2]] = i;
            }
        }
        
        // Traverse the tree to identify roots
        for (int i = 0; i < tree.size(); ++i) {
            if (tree[i] != -1 && to_delete_set.find(tree[i]) == to_delete_set.end()) {
                int j = i;
                while (j != -1 && to_delete_set.find(tree[j]) == to_delete_set.end()) {
                    j = parent[j];
                }
                if (j == -1 || roots.find(j) == roots.end()) {
                    roots.insert(i);
                }
            }
        }
        
        // Create the resulting forest
        for (int root : roots) {
            vector<int> sub_tree;
            dfs(tree, root, to_delete_set, sub_tree);
            result.push_back(sub_tree);
        }
        
        return result;
    }
    
private:
    void dfs(vector<int>& tree, int node, unordered_set<int>& to_delete_set, vector<int>& sub_tree) {
        if (node == -1 || to_delete_set.find(tree[node]) != to_delete_set.end()) {
            return;
        }
        
        sub_tree.push_back(tree[node]);
        int left_child = node * 2 + 1;
        int right_child = node * 2 + 2;
        
        // Recursively traverse the left and right subtrees
        dfs(tree, left_child, to_delete_set, sub_tree);
        dfs(tree, right_child, to_delete_set, sub_tree);
    }
};

int main() {
    // Test cases
    vector<int> tree1 = {1, 2, 3};
    vector<int> to_delete1 = {1};
    Solution solution1;
    vector<vector<int>> result1 = solution1.delNodes(tree1, to_delete1);
    for (const vector<int>& tree : result1) {
        for (int val : tree) {
            cout << val << " ";
        }
        cout << endl;
    }
    // Output: 
    // 2 
    // 3 

    vector<int> tree2 = {1, 2, 3, -1, -1, 4};
    vector<int> to_delete2 = {4};
    Solution solution2;
    vector<vector<int>> result2 = solution2.delNodes(tree2, to_delete2);
    for (const vector<int>& tree : result2) {
        for (int val : tree) {
            cout << val << " ";
        }
        cout << endl;
    }
    // Output: 
    // 1 2 3 

    vector<int> tree3 = {1, 2, 3, 4, 5, 6, 7};
    vector<int> to_delete3 = {3, 5};
    Solution solution3;
    vector<vector<int>> result3 = solution3.delNodes(tree3, to_delete3);
    for (const vector<int>& tree : result3) {
        for (int val : tree) {
            cout << val << " ";
        }
        cout << endl;
    }
    // Output: 
    // 1 2 4 
    // 6 
    // 7 

    return 0;
}

/*

 we use a vector to represent the tree, where each element in the vector corresponds to a node in the binary tree. The index of the vector elements follows the rules for a binary heap representation, where the left child of a node at index i is at index 2i + 1, and the right child is at index 2i + 2.

Here's an explanation of the code:

We define a Solution class to encapsulate the solution. This class contains a delNodes method that takes two vectors as input: tree, which represents the binary tree, and to_delete, which contains the values of nodes to be deleted.

We create an unordered set to_delete_set from the to_delete vector for efficient lookup to determine which nodes should be deleted.

We initialize an empty vector result to store the resulting forest of trees.

We also initialize an unordered set roots to keep track of the root nodes of trees in the forest.

We create a parent vector to maintain the parent-child relationships in the tree. For each non-null node in the tree vector, we set the corresponding indices in the parent vector to the index of the parent node.

We traverse the tree vector to identify the root nodes of trees in the forest. If a node is not in the to_delete_set and is not a descendant of any node in the to_delete_set, it is considered a root node and added to the roots set.

We then iterate through the roots set, and for each root, we perform a depth-first traversal of the tree, constructing a subtree in a vector called sub_tree. Nodes that are in the to_delete_set or their descendants are skipped during this traversal.

Finally, we add each sub_tree to the result vector, and after processing all root nodes, we return the result.

The code has been tested with three examples at the end to demonstrate how it works. It creates a forest of trees based on the given tree and nodes to delete and prints the resulting trees in the specified format.

*/
